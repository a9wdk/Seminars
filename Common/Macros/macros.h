#ifndef __MACROS_H__
#define __MACROS_H__

//*****************************************************************************
// Описание поисковых сигнатур и структур данных, используемых для 
// передачи информации во вспомогательную утилиту. Файл должен быть включен
// как в проект защищенного приложения, так и в проект вспомогательной
// утилиты.
//
// Автор - Сергей Усков (a9wdk@yandex.ru, Telegram: @a9wdk)
//*****************************************************************************

#define MaxEccLength  256       // Максимальная длина кода коррекции ошибок (в байтах), используемая в приложении.

#define DB      __asm _emit

#define int3    __asm int 3     \
                __asm nop

//////////////////////////////////////////////////////////////////////////////////////////////
// Структура-дескриптор сессии с ключом.
#ifdef __HASP_API_H__

typedef struct _HaspSession {
    hasp_handle_t   handle;     // Хендл текущей сессии с ключом.
    hasp_status_t   status;     // Код ошибки последней операции.
    hasp_feature_t  feature;    // Feature ID для текущей сессии.
} HaspSession, *PHaspSession;

#endif  //__HASP_API_H__

//######################################################################################################
//#                 Структуры для обеспечения зашифрования данных на post-build этапе                  #
//######################################################################################################

// Маркер, содержащий информацию о данных, которые требуется зашифровать на custom-алгоритме. Обрабатывается 
// утилитой DataEncrypt, после чего перезаписывается случайными данными, т.к. далее нигде не используется.

#define CstEncDataSig   "-C-E-D-"       // Поисковая сигнатура, записываемая в начало маркера.

typedef struct _CstEncDataMrk {
    CHAR  Signature[8];     // Место для поисковой сигнатуры. Используется для обнаружения маркера утилитой.
    PVOID Addr;             // Адрес данных.
    DWORD Length;           // Длина данных.
} CstEncDataMrk, *PCstEncDataMrk;   

// Маркер, содержащий информацию о данных, которые требуется зашифровать на алгоритме AES через ключ. Обрабатывается 
// утилитой DataEncrypt, после чего перезаписывается случайными данными, т.к. далее нигде не используется.
#ifdef __HASP_API_H__

#define KeyEncDataSig   "-K-E-D-"       // Поисковая сигнатура, записываемая в начало маркера.

typedef struct _KeyEncDataMrk {
    CHAR  Signature[8]; // Место для поисковой сигнатуры. Используется для обнаружения маркера утилитой.
    PVOID Addr;         // Адрес данных.
    DWORD Length;       // Длина данных.
    DWORD Feature;      // Feature ID, на которой зашифровываются данные.
} KeyEncDataMrk, *PKeyEncDataMrk;

#endif  //__HASP_API_H__

//######################################################################################################
//#    Структуры для обеспечения контроля целостности данных и кода при помощи хэш-функций (CRC32)     #
//######################################################################################################

// Структура-дескриптор, содержит данные о размещении, длине и эталонной контрольной сумме участка
// данных/кода. Используется во время работы защищенного приложения для контроля целостности участка.
// Заполняется утилитой CRC32Protect на основе информации, полученной из маркеров данных/кода.

typedef struct _CrcDsc {        
    PBYTE   NextDsc;        // Адрес следующего дескриптора, для последнго - NULL
    PBYTE   Addr;           // Адрес данных.
    DWORD   Length;         // Длина данных.
    DWORD   OrgCrc;         // Эталонная контрольная сумма.
    DWORD   CurrCrc;        // Текущая контрольная сумма (используется для вывода диагностики).
    DWORD   Id;             // Идентификатор, используется для вывода диагностики при отладке защиты.
    BOOL    ValidateFlag;   // Соответствует ли дескриптор текущему ImageBase (для приложений с Fixup's)
} CrcDsc, *PCrcDsc;

//------------------------------- ТОЧКА ВХОДА В СПИСОК ДЕСКРИПТОРОВ ------------------------------------

// Структура-контейнер, содержит точку входа в односвязный список дескрипторов _CrcDsc. В случае обнаружения
// данной структуры, утилита CRC32Protect формирует из найденных дескрипторов _CrcDsc список, связывая их через
// поле NextDsc, после чего помещает точку входа списка в поле EntryPoint структуры _CrcDscList. Поле Signature
// заполняется случайными данными для маскировки структуры.

#define CrcDscListSig   "-C-R-E-"       // Поисковая сигнатура, записываемая в начало маркера.

typedef struct _CrcDscList {
    CHAR    Signature[8];   // Место для поисковой сигнатуры. Используется для обнаружения контейнера утилитой.
    PCrcDsc EntryPoint;     // Точка входа в список дескрипторов _CrcDsc
} CrcDscList, *PCrcDscList;

//------------------------------------- МАРКЕР ЗАЩИТЫ ДАННЫХ -------------------------------------------

// Маркер, содержащий информацию о данных, для которых требуется расчитать контрольную сумму. Обрабатывается 
// утилитой CRC32Protect, после чего перезаписывается случайными данными, т.к. далее нигде не используется.

#define CrcDataSig  "-C-R-D-"           // Поисковая сигнатура, записываемая в начало маркера.

typedef struct _CrcDataMrk {
    CHAR    Signature[8];   // Место для поисковой сигнатуры. Используется для обнаружения маркера утилитой.
    PCrcDsc CrcDscAddr;     // Адрес структуры-дескриптора, соответствующей данному маркеру.
    PVOID   Addr;           // Адрес данных.
    DWORD   Length;         // Длина данных.
    DWORD   Id;             // Идентификатор маркера, используется для вывода диагностики при защите приложения.
} CrcDataMrk, *PCrcDataMrk;

//----------------------------------- МАРКЕР ЗАЩИТЫ СВОЕГО КОДА  ---------------------------------------

// Маркер, содержащий информацию об участке кода, для которого требуется расчитать контрольную сумму. 
// Представлен в двух форматах, а именно - как ассемблерная вставка, т.к. внедрение маркера в приложение
// производится в область исполняемого кода, поскольку требуется работать с метками, и, как обычная структура
// данных, полностью соответствующая ассемблерной вставке, используемая для извлечения информации в утилите
// CRC32Protect. После извлечения перезаписывается случайными данными, т.к. далее нигде не используется.

// Поисковая сигнатура, записываемая в начало маркера, так же, представлена в двух форматах.
#define CrcCodeSig      "-C-R-C-"                                           // Для _CrcCodeMrk
#define AsmCrcCodeSig   DB '-' DB 'C' DB '-' DB 'R' DB '-' DB 'C' DB '-'    // Для AsmCrcCodeMrk

// Маркер для внедрения в исходный код приложения.
#define AsmCrcCodeMrk(DescriptorAddr, StartAddr, EndAddr, Id)   \
        AsmCrcCodeSig                                           \
        __asm mov EAX, offset DescriptorAddr                    \
        __asm mov EAX, offset StartAddr                         \
        __asm mov EAX, offset EndAddr                           \
        __asm mov EAX, Id

// Маркер для извлечения информации в утилите CRC32Protect.
#pragma pack(push, 1)       // Выравнивание элементов структуры по границе байта
typedef struct _CrcCodeMrk {
    CHAR  Signature[7];     // Место для поисковой сигнатуры. Используется для обнаружения маркера утилитой.
    BYTE  OpCode0;
    DWORD DescriptorAddr;   // Адрес структуры-дескриптора, соответствующей данному маркеру.
    BYTE  OpCode1;
    DWORD StartAddr;        // Адрес начала участка кода.
    BYTE  OpCode2;
    DWORD EndAddr;          // Адрес конца участка кода.
    BYTE  OpCode3;
    DWORD Id;               // Идентификатор маркера, используется для вывода диагностики при защите приложения.
} CrcCodeMrk, *PCrcCodeMrk;
#pragma pack(pop)

//--------------------------- МАРКЕР ЗАЩИТЫ БИБЛИОТЕЧНОГО (ЧУЖОГО) КОДА  -------------------------------

// Маркер, содержащий информацию об участке библиотечного кода, для которого требуется расчитать контрольную
// сумму. Представлен в двух форматах, а именно - как ассемблерная вставка, т.к. внедрение маркера в приложение
// производится в область исполняемого кода, поскольку требуется работать с произвольными адресами, и, как 
// обычная структура данных, полностью соответствующая ассемблерной вставке, используемая для извлечения информации
// в утилите CRC32Protect. После извлечения перезаписывается случайными данными, т.к. далее нигде не используется.

// Поисковая сигнатура, записываемая в начало маркера, так же, представлена в двух форматах.
#define CrcLibsSig      "-C-R-L-"                                           // Для _CrcLibsMrk
#define AsmCrcLibsSig   DB '-' DB 'C' DB '-' DB 'R' DB '-' DB 'L' DB '-'    // Для AsmCrcLibsMrk

// Маркер для внедрения в исходный код приложения.
#define AsmCrcLibsMrk(DescriptorAddr, EntryPointAddr, CodeLength, Id)   \
        AsmCrcLibsSig                                                   \
        __asm mov EAX, offset DescriptorAddr                            \
        __asm mov EAX, offset EntryPointAddr                            \
        __asm mov EAX, CodeLength                                       \
        __asm mov EAX, Id

// Маркер для извлечения информации в утилите CRC32Protect.
#pragma pack(push, 1)       // Выравнивание элементов структуры по границе байта
typedef struct _CrcLibsMrk {
    CHAR  Signature[7];     // Место для поисковой сигнатуры. Используется для обнаружения маркера утилитой.
    BYTE  OpCode0;
    DWORD DescriptorAddr;   // Адрес структуры-дескриптора, соответствующей данному маркеру.
    BYTE  OpCode1;
    DWORD EntryPointAddr;   // Точка входа защищаемого участка библиотечного кода.
    BYTE  OpCode2;
    DWORD CodeLength;       // Длина защищаемого участка библиотечного кода.
    BYTE  OpCode3;
    DWORD Id;               // Идентификатор маркера, используется для вывода диагностики при защите приложения.
} CrcLibsMrk, *PCrcLibsMrk;
#pragma pack(pop)


//######################################################################################################
//#     Структуры для обеспечения помехозащищенного кодирования данных и кода (коды Рида-Соломона)     #
//######################################################################################################
#ifdef __RSLIB_H__

// Если не задана максимальная длина кода коррекции ошибок, которая может быть использована в приложении,
// берётся значение ECC_MAX из RSLib.h

#ifndef MaxEccLength
    #define MaxEccLength ECC_MAX
#endif

// Структура-дескриптор, содержит данные о размещении, длине и коде коррекции ошибок (ECC) участка данных/кода.
// Используется во время работы защищенного приложения для восстановления целостности участка в случае внесения
// в него изменений. Заполняется утилитой ECCProtect на основе информации, полученной из маркеров данных/кода.

typedef struct _EccDsc {        
    PBYTE   NextDsc;            // Адрес следующего дескриптора, для последнго - NULL
    PBYTE   Addr;               // Адрес данных.
    DWORD   Length;             // Длина данных.
    DWORD   EccLength;          // Длина кода коррекции ошибок.
    DWORD   Id;                 // Идентификатор, используется для вывода диагностики при отладке защиты.
    BOOL    ValidateFlag;       // Соответствует ли дескриптор текущему ImageBase (для приложений с Fixup's)
    BYTE    Ecc[MaxEccLength];  // Код коррекции ошибок.
} EccDsc, *PEccDsc;

//------------------------------- ТОЧКА ВХОДА В СПИСОК ДЕСКРИПТОРОВ ------------------------------------

// Структура-контейнер, содержит точку входа в односвязный список дескрипторов _EccDsc. В случае обнаружения
// данной структуры, утилита ECCProtect формирует из найденных дескрипторов _EccDsc список, связывая их через
// поле NextDsc, после чего помещает точку входа списка в поле EntryPoint структуры _EccDscList. Поле Signature
// заполняется случайными данными для маскировки структуры.

#define EccDscListSig   "-E-C-E-"       // Поисковая сигнатура, записываемая в начало маркера.

typedef struct _EccDscList {
    CHAR    Signature[8];   // Место для поисковой сигнатуры. Используется для обнаружения контейнера утилитой.
    PEccDsc EntryPoint;     // Точка входа в список дескрипторов _EccDsc
} EccDscList, *PEccDscList;

//------------------------------------- МАРКЕР ЗАЩИТЫ ДАННЫХ -------------------------------------------

// Маркер, содержащий информацию о данных, для которых требуется расчитать код коррекции ошибок. Обрабатывается 
// утилитой ECCProtect, после чего перезаписывается случайными данными, т.к. далее нигде не используется.

#define EccDataSig  "-E-C-D-"           // Поисковая сигнатура, записываемая в начало маркера.

typedef struct _EccDataMrk {
    CHAR     Signature[8];  // Место для поисковой сигнатуры. Используется для обнаружения маркера утилитой.
    PEccDsc  EccDscAddr;    // Адрес структуры-дескриптора, соответствующей данному маркеру.
    PVOID    Addr;          // Адрес данных.
    DWORD    Length;        // Длина данных.
    DWORD    EccLength;     // Длина кода коррекции ошибок.
    DWORD    Id;            // Идентификатор маркера, используется для вывода диагностики при защите приложения.
} EccDataMrk, *PEccDataMrk;


//----------------------------------- МАРКЕР ЗАЩИТЫ СВОЕГО КОДА  ---------------------------------------

// Маркер, содержащий информацию об участке кода, для которого требуется расчитать код коррекции ошибок. 
// Представлен в двух форматах, а именно - как ассемблерная вставка, т.к. внедрение маркера в приложение
// производится в область исполняемого кода, поскольку требуется работать с метками, и, как обычная структура
// данных, полностью соответствующая ассемблерной вставке, используемая для извлечения информации в утилите
// ECCProtect. После извлечения информации перезаписывается случайными данными, т.к. далее нигде не используется.

// Поисковая сигнатура, записываемая в начало маркера, так же, представлена в двух форматах.
#define EccCodeSig      "-E-C-C-"                                           // Для _EccCodeMrk
#define AsmEccCodeSig   DB '-' DB 'E' DB '-' DB 'C' DB '-' DB 'C' DB '-'    // Для AsmEccCodeMrk

// Маркер для внедрения в исходный код приложения.
#define AsmEccCodeMrk(DescriptorAddr, StartAddr, EndAddr, EccLength, Id)    \
        AsmEccCodeSig                                                       \
        __asm mov EAX, offset DescriptorAddr                                \
        __asm mov EAX, offset StartAddr                                     \
        __asm mov EAX, offset EndAddr                                       \
        __asm mov EAX, EccLength                                            \
        __asm mov EAX, Id

// Маркер для извлечения информации в утилите ECCProtect.
#pragma pack(push, 1)       // Выравнивание элементов структуры по границе байта
typedef struct _EccCodeMrk {
    CHAR  Signature[7];     // Место для поисковой сигнатуры. Используется для обнаружения маркера утилитой.
    BYTE  OpCode0;
    DWORD DescriptorAddr;   // Адрес структуры-дескриптора, соответствующей данному маркеру.
    BYTE  OpCode1;
    DWORD StartAddr;        // Адрес начала участка кода.
    BYTE  OpCode2;
    DWORD EndAddr;          // Адрес конца участка кода.
    BYTE  OpCode3;
    DWORD EccLength;        // Длина кода коррекции ошибок.
    BYTE  OpCode4;
    DWORD Id;               // Идентификатор маркера, используется для вывода диагностики при защите приложения.
} EccCodeMrk, *PEccCodeMrk;
#pragma pack(pop)

//--------------------------- МАРКЕР ЗАЩИТЫ БИБЛИОТЕЧНОГО (ЧУЖОГО) КОДА  -------------------------------

// Маркер, содержащий информацию об участке библиотечного кода, для которого требуется расчитать код коррекции
// ошибок. Представлен в двух форматах, а именно - как ассемблерная вставка, т.к. внедрение маркера в приложение
// производится в область исполняемого кода, поскольку требуется работать с произвольными адресами, и, как 
// обычная структура данных, полностью соответствующая ассемблерной вставке, используемая для извлечения информации
// в утилите ECCProtect. После извлечения перезаписывается случайными данными, т.к. далее нигде не используется.

// Поисковая сигнатура, записываемая в начало маркера, так же, представлена в двух форматах.
#define EccLibsSig      "-E-C-L-"                                           // Для _EccLibsMrk
#define AsmEccLibsSig   DB '-' DB 'E' DB '-' DB 'C' DB '-' DB 'L' DB '-'    // Для AsmEccLibsMrk

// Маркер для внедрения в исходный код приложения.
#define AsmEccLibsMrk(DescriptorAddr, EntryPointAddr, CodeLength, EccLength, Id)    \
        AsmEccLibsSig                                                               \
        __asm mov EAX, offset DescriptorAddr                                        \
        __asm mov EAX, offset EntryPointAddr                                        \
        __asm mov EAX, CodeLength                                                   \
        __asm mov EAX, EccLength                                                    \
        __asm mov EAX, Id   

// Маркер для извлечения информации в утилите ECCProtect.
#pragma pack(push, 1)       // Выравнивание элементов структуры по границе байта
typedef struct _EccLibsMrk {
    char  Signature[7];     // Место для поисковой сигнатуры. Используется для обнаружения маркера утилитой.
    BYTE  OpCode0;
    DWORD DescriptorAddr;   // Адрес структуры-дескриптора, соответствующей данному маркеру.
    BYTE  OpCode1;
    DWORD EntryPointAddr;   // Точка входа защищаемого участка библиотечного кода.
    BYTE  OpCode2;
    DWORD CodeLength;       // Длина защищаемого участка библиотечного кода.
    BYTE  OpCode3;
    DWORD EccLength;        // Длина кода коррекции ошибок.
    BYTE  OpCode4;
    DWORD Id;               // Идентификатор маркера, используется для вывода диагностики при защите приложения.
} EccLibsMrk, *PEccLibsMrk;
#pragma pack(pop)

#endif  // __RSLIB_H__

//######################################################################################################
//# Структуры для обеспечения динамического зашифрования/расшифрования кода во время работы приложения #
//######################################################################################################

//------------------------ ДИНАМИЧЕСКОЕ ШИФРОВАНИЕ КОДА НА CUSTOM-АЛГОРИТМЕ ----------------------------

// Структура-дескриптор, содержит данные о размещении и длине зашифрованного на custom-алгоритме участка кода.
// Используется во время работы защищенного приложения для динамического расшифрования/зашифрования этого участка.
// Зашифрование участка кода и заполнение дескриптора данными осуществляются утилитой CodeEncrypt на основе 
// информации, полученной из маркера AsmCstEncCodeMrk.

typedef struct _CstEncCodeDsc {
    PBYTE   Addr;           // Адрес начала участка кода.
    DWORD   Length;         // Длина участка кода.
    BOOL    ValidateFlag;   // Соответствует ли дескриптор текущему ImageBase (для приложений с Fixup's) 
} CstEncCodeDsc, *PCstEncCodeDsc;

// Маркер, содержащий информацию об участке кода, который требуется зашифровать на custom-алгоритме. 
// Представлен в двух форматах, а именно - как ассемблерная вставка, т.к. внедрение маркера в приложение
// производится в область исполняемого кода, поскольку требуется работать с метками, и, как обычная структура
// данных, полностью соответствующая ассемблерной вставке, используемая для извлечения информации в утилите
// CodeEncrypt. После извлечения информации перезаписывается случайными данными, т.к. далее нигде не используется.

// Поисковая сигнатура, записываемая в начало маркера, так же, представлена в двух форматах.
#define CstEncCodeSig       "-C-E-C-"                                           // Для _CstEncCodeMrk
#define AsmCstEncCodeSig    DB '-' DB 'C' DB '-' DB 'E' DB '-' DB 'C' DB '-'    // Для AsmCstEncCodeMrk

// Маркер для внедрения в исходный код приложения.
#define AsmCstEncCodeMrk(DescriptorAddr, StartAddr, EndAddr)    \
        AsmCstEncCodeSig                                        \
        __asm mov EAX, offset DescriptorAddr                    \
        __asm mov EAX, offset StartAddr                         \
        __asm mov EAX, offset EndAddr   

// Маркер для извлечения информации в утилите CodeEncrypt.
#pragma pack(push, 1)       // Выравнивание элементов структуры по границе байта
typedef struct _CstEncCodeMrk {
    CHAR  Signature[7];     // Место для поисковой сигнатуры. Используется для обнаружения маркера утилитой.
    BYTE  OpCode0;
    DWORD DescriptorAddr;   // Адрес структуры-дескриптора, соответствующей данному маркеру.
    BYTE  OpCode1;
    DWORD StartAddr;        // Адрес начала участка кода.
    BYTE  OpCode2;
    DWORD EndAddr;          // Адрес конца участка кода.
} CstEncCodeMrk, *PCstEncCodeMrk;
#pragma pack(pop)

//-------------------- ДИНАМИЧЕСКОЕ ШИФРОВАНИЕ КОДА НА АЛГОРИТМЕ AES ЧЕРЕЗ КЛЮЧ ------------------------
#ifdef __HASP_API_H__

// Структура-дескриптор, содержит данные о размещении и длине зашифрованного на алгоритме AES (через ключ) участка
// кода. Используется во время работы защищенного приложения для динамического расшифрования/зашифрования этого
// участка. Зашифрование участка кода и заполнение дескриптора данными осуществляются утилитой CodeEncrypt на основе 
// информации, полученной из маркера AsmKeyEncCodeMrk.

typedef struct _KeyEncCodeDsc {
    PHaspSession    KeySessionAddr;     // Адрес дескриптора сессии с ключом, обеспечивающей криптооперации с кодом.
    PBYTE           Addr;               // Адрес начала участка кода.
    DWORD           Length;             // Длина участка кода.
    BOOL            ValidateFlag;       // Соответствует ли дескриптор текущему ImageBase (для приложений с Fixup's) 
} KeyEncCodeDsc, *PKeyEncCodeDsc;

// Маркер, содержащий информацию об участке кода, который требуется зашифровать на алгоритме AES через ключ.
// Представлен в двух форматах, а именно - как ассемблерная вставка, т.к. внедрение маркера в приложение
// производится в область исполняемого кода, поскольку требуется работать с метками, и, как обычная структура
// данных, полностью соответствующая ассемблерной вставке, используемая для извлечения информации в утилите
// CodeEncrypt. После извлечения информации перезаписывается случайными данными, т.к. далее нигде не используется.

// Поисковая сигнатура, записываемая в начало маркера, так же, представлена в двух форматах.
#define KeyEncCodeSig       "-K-E-C-"                                           // Для _KeyEncCodeMrk
#define AsmKeyEncCodeSig    DB '-' DB 'K' DB '-' DB 'E' DB '-' DB 'C' DB '-'    // Для AsmKeyEncCodeMrk

// Маркер для внедрения в исходный код приложения.
#define AsmKeyEncCodeMrk(DescriptorAddr, StartAddr, EndAddr, KeySessionAddr)    \
        AsmKeyEncCodeSig                                                        \
        __asm mov EAX, offset DescriptorAddr                                    \
        __asm mov EAX, offset StartAddr                                         \
        __asm mov EAX, offset EndAddr                                           \
        __asm mov EAX, offset KeySessionAddr

// Маркер для извлечения информации в утилите CodeEncrypt.
#pragma pack(push, 1)       // Выравнивание элементов структуры по границе байта
typedef struct _KeyEncCodeMrk {
    CHAR  Signature[7];     // Место для поисковой сигнатуры. Используется для обнаружения маркера утилитой.
    BYTE  OpCode0;
    DWORD DescriptorAddr;   // Адрес структуры-дескриптора, соответствующей данному маркеру.
    BYTE  OpCode1;
    DWORD StartAddr;        // Адрес начала участка кода.
    BYTE  OpCode2;
    DWORD EndAddr;          // Адрес конца участка кода.
    BYTE  OpCode3;
    DWORD KeySessionAddr;   // Адрес дескриптора сессии с ключом, обеспечивающей криптооперации с кодом.
} KeyEncCodeMrk, *PKeyEncCodeMrk;
#pragma pack(pop)

#endif  //__HASP_API_H__

//----- ПОДДЕРЖКА ДИНАМИЧЕСКОГО ШИФРОВАНИЯ КОДА ЧЕРЕЗ МЕХАНИЗМЫ ОБРАБОТКИ ИСКЛЮЧИТЕЛЬНЫХ СИТУАЦИЙ ------

// Отключение предупреждений компилятора о том, что устанавливаемые обработчики исключительных ситуаций не
// являются надежными. Источником предупреждений является механизм SafeSEH (защита от подмены SEH-обработчика
// при атаке на переполняющиеся буфера). 

#pragma warning(disable : 4733)

// Установка внутрипоточного SEH-обработчика исключительной ситуации. Создаем на стеке SEH-Record (узел) 
// обработчика и регистрируем его как текущий:
// push offset ExceptionHandler -> помещаем в стек адрес устанавливаемого обработчика исключительной ситуации.
// push FS:[0]                  -> помещаем в стек адрес SEH-Record предыдущего обработчика.
// mov  FS:[0], ESP             -> регистрируем только что созданную SEH-Record, как узел текущего обработчика.

#define InstallHandler(ExceptionHandler)        \
        __asm push offset ExceptionHandler      \
        __asm push FS:[0]                       \
        __asm mov  FS:[0], ESP

// Снятие текущего внутрипоточного SEH-обработчика исключительной ситуации. Регистрируем в качестве текущего
// предыдущий обработчик, помещая адрес его узла обратно в FS:[0] из первого поля SEH-Record, после чего
// удаляем из стека второе поле SEH-Record, более нам не нужное: 
// pop  dword ptr FS:[0]    -> регистрируем узел предыдущего обработчика (SEH-Record), как текущий.
// add  ESP, 4              -> удаляем из стека остатки SEH-Record. Ну, можно, нпример, и так - pop EAX.

#define RemoveHandler                           \
        __asm pop  dword ptr FS:[0]             \
        __asm add  ESP, 4


// РАСШИФРОВАНИЕ УЧАСТКА КОДА НА CUSTOM-АЛГОРИТМЕ. Макроопределение RaiseExceptionForCustomDecrypt формирует
// "пятно", вызывающее исключение при проходе управления по нему. "Пятно", так же, содержит дескриптор участка
// кода и адрес точки входа, куда нужно передать управление после завершения обработки исключительной ситуации.
// Доступ к параметрам, лежащим в "пятне", из обработчика исключения осуществляется через структуру _RaiseExcept.

#define CstDecInvalidOpCode     0x3A0F              // Для использования с _RaiseExcept.InvalidOpCode
#define AsmCstDecInvalidOpCode  DB 0x0F DB 0x3A     // Для RaiseExceptionForCustomDecrypt (Little Endian)

#define RaiseExceptionForCustomDecrypt(Descriptor, SafeEIP)     \
        AsmCstDecInvalidOpCode                                  \
        __asm mov  ESP, offset Descriptor                       \
        __asm mov  ESP, SafeEIP

// ЗАШИФРОВАНИЕ УЧАСТКА КОДА НА CUSTOM-АЛГОРИТМЕ. Макроопределение RaiseExceptionForCustomEncrypt формирует
// "пятно", вызывающее исключение при проходе управления по нему. "Пятно", так же, содержит дескриптор участка
// кода и адрес точки входа, куда нужно передать управление после завершения обработки исключительной ситуации.
// Доступ к параметрам, лежащим в "пятне", из обработчика исключения осуществляется через структуру _RaiseExcept.

#define CstEncInvalidOpCode     0x3B0F              // Для использования с _RaiseExcept.InvalidOpCode
#define AsmCstEncInvalidOpCode  DB 0x0F DB 0x3B     // Для RaiseExceptionForCustomEncrypt (Little Endian)

#define RaiseExceptionForCustomEncrypt(Descriptor, SafeEIP)     \
        AsmCstEncInvalidOpCode                                  \
        __asm mov  ESP, offset Descriptor                       \
        __asm mov  ESP, SafeEIP

// РАСШИФРОВАНИЕ УЧАСТКА КОДА НА АЛГОРИТМЕ AES ЧЕРЕЗ КЛЮЧ. Макроопределение RaiseExceptionForKeyDecrypt формирует
// "пятно", вызывающее исключение при проходе управления по нему. "Пятно", так же, содержит дескриптор участка
// кода и адрес точки входа, куда нужно передать управление после завершения обработки исключительной ситуации.
// Доступ к параметрам, лежащим в "пятне", из обработчика исключения осуществляется через структуру _RaiseExcept.

#define KeyDecInvalidOpCode     0x3C0F              // Для использования с _RaiseExcept.InvalidOpCode
#define AsmKeyDecInvalidOpCode  DB 0x0F DB 0x3C     // Для RaiseExceptionForKeyDecrypt (Little Endian)

#define RaiseExceptionForKeyDecrypt(Descriptor, SafeEIP)        \
        AsmKeyDecInvalidOpCode                                  \
        __asm mov  ESP, offset Descriptor                       \
        __asm mov  ESP, SafeEIP

// ЗАШИФРОВАНИЕ УЧАСТКА КОДА НА АЛГОРИТМЕ AES ЧЕРЕЗ КЛЮЧ. Макроопределение RaiseExceptionForKeyEncrypt формирует
// "пятно", вызывающее исключение при проходе управления по нему. "Пятно", так же, содержит дескриптор участка
// кода и адрес точки входа, куда нужно передать управление после завершения обработки исключительной ситуации.
// Доступ к параметрам, лежащим в "пятне", из обработчика исключения осуществляется через структуру _RaiseExcept.

#define KeyEncInvalidOpCode     0x3D0F              // Для использования с _RaiseExcept.InvalidOpCode
#define AsmKeyEncInvalidOpCode  DB 0x0F DB 0x3D     // Для RaiseExceptionForKeyEncrypt (Little Endian)  

#define RaiseExceptionForKeyEncrypt(Descriptor, SafeEIP)        \
        AsmKeyEncInvalidOpCode                                  \
        __asm mov  ESP, offset Descriptor                       \
        __asm mov  ESP, SafeEIP

// Mакроопределения RaiseExceptionFor**, формирующие "пятно", создают характерную стационарную сигнатуру вида
// "0F xx BC xx xx xx xx BC xx xx xx xx". Утилита CodeEncrypt разыскивает такие сигнатуры и меняет опкоды
// инструкций, в операндах которых лежат параметры "пятна", на случайные данные, таким образом маскируя сигнатуры.

#define FirstByteBadOpCode  0x0F    // Первый байт всех "плохих" инструкций
#define ExceptionDataOpCode 0xBC    // Опкод инструкции mov ESP,... используемой как контейнер параметра. 

// Структура _RaiseExcept полностью соответствует макроопределениям RaiseExceptionFor**, формирующим "пятно",
// вызывающее исключение, и служит для получения параметров "пятна" изнутри обработчика исключительной ситуации.

#pragma pack(push, 1)           // Выравнивание элементов структуры по границе байта
typedef struct _RaiseExcept {
    WORD  InvalidOpCode;        // "Плохая" инструкция, вызывающая исключение.
    BYTE  OpCode0;
    DWORD DescriptorAddr;       // Адрес дескриптора, описывающего зашифрованный участок кода.
    BYTE  OpCode1;
    DWORD SafeEIPAddr;          // Адрес безопасной точки входа, куда передается управление после обработки исключения.
} RaiseExcept, *PRaiseExcept;   // Если SafeEIPAddr == NULL - то на следующую, после структуры RaiseExcept, инструкцию.
#pragma pack(pop)


//######################################################################################################
//#                    Структуры для обеспечения использования функций TLS_Callback                    #
//######################################################################################################

#define TLSDirSign  "-T-L-S-"           // Поисковая сигнатура, записываемая в начало маркера.

// Структура, содержащая поисковую сигнатуру и адрес TLS_Directory. Используется для передачи 
// адреса TLS_Directory в утилиту ECCProtect, подключаемую на post-build этапе. ECCProtect,
// запущенная с параметром /tls, зарегистрирует TLS_Directory в PE-заголовке целевого файла.

typedef struct _TLS {   
    CHAR    Signature[8];   // Место для поисковой сигнатуры. Используется для обнаружения маркера утилитой.
    PVOID   TlsDirAddr;     // Адрес TLS_Directory
} TLS, *PTLS;


//######################################################################################################
//#                 Структуры для обеспечения противодействия табличной эмуляции ключа                 #
//######################################################################################################

// Часть инструкций закодирована непосредственно в машинных кодах - это сделано с целью избежать
// использования внутри макросов символьных меток, что позволяет предотвратить конфликт между метками
// по именам в случае многократного использования макроса в пределах кода одной и той же процедуры. 

// Размещение четырехбайтовой переменной (DWORD) внутри исполняемого кода. Первые два байта 
// (EBh 04h) - инструкция короткого перехода для обхода переменной, var - метка для взятия
// адреса, где будет размещена переменная.

#define DWORDVarInCode(var)                             \
            __asm       DB 0xEB DB 0x04                 \
            __asm  var: DB 0 DB 0 DB 0 DB 0

// Самодостаточный базонезависимый фрагмент, не связанный с логикой работы окружающего его кода.
// При каждом проходе управления сохраняет внутри себя текущее значение системного таймера (двойное
// слово в предпоследней инструкции). Это приводит к тому, что при каждом проходе управления меняется
// сигнатура фрагмента, таким образом, создавая изменяющийся случайным образом "шум" в текущей локации. 

// DB 0xE8 DB 0 DB 0 DB 0 DB 0 - инструкция call $+5 (помещает в стек адрес следующей инструкции, длина call - 5 байт)
// DB 0xEB DB 0x04             - инструкция jmp  $+2+4 ($ - адрес текущей инструкции, длина jmp short - 2 байта)
// DB 0 DB 0 DB 0 DB 0         - место для хранения текущего значения системного таймера.

#define NoiseInCode()   GetTickCount();                 \
            __asm       push EBX                        \
            __asm       DB 0xE8 DB 0 DB 0 DB 0 DB 0     \
            __asm       pop  EBX                        \
            __asm       add  EBX, 8                     \
            __asm       mov  dword ptr [EBX], EAX       \
            __asm       DB 0xEB DB 0x04                 \
            __asm       DB 0 DB 0 DB 0 DB 0             \
            __asm       pop  EBX


//######################################################################################################
//#   Структуры для обеспечения использования чувствительных к fixup'ам алгоритмов совместно с ними    #
//######################################################################################################

// Структура-контейнер для хранения оригинального значения ImageBase. Если приложение собрано с использованием
// технологии ASLR (Address Space Layout Randomization), то в процессе загрузки базовый адрес приложения будет
// произвольно изменен системным загрузчиком путем перезаписи исходного значения в PE-заголовке образа. После
// этого узнать исходное значение ImageBase, с использованием которого считались хэш-суммы, коды коррекции 
// ошибок и зашифровывался код, будет невозможно. Поэтому ImageBase заранее сохраняется в данный контейнер одной
// из следующих утилит: CRC32Protect, ECCProtect или CodeEncrypt. В случае, если контейнер обнаружен одной из них,
// он заполняется с выдачей соответствующей информации в окно вывода. В случае, если контейнер не обнаружен,
// никаких предупреждений не выдается, поэтому за необходимостью наличия контейнера нужно следить самостоятельно. 

#define OrgPESig    "-O-I-B-"       // Поисковая сигнатура, записываемая в начало маркера.

typedef struct _OrgPE {
    CHAR    Signature[8];   // Место для поисковой сигнатуры. Используется для обнаружения контейнера утилитой.
    DWORD   ImageBase;      // Исходное значение ImageBase
} OrgPE, *POrgPE;

//BYTE  AddrStub;           // Заглушка, используется для инициализации адресных полей целевых дескрипторов,
                            // чтобы при сборке эти поля были помечены компоновщиком, как перемещаемые элементы.


#endif // __MACROS_H__