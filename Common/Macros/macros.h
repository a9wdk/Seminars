#ifndef __MACROS_H__
#define __MACROS_H__

//*****************************************************************************
// Описание поисковых сигнатур и структур данных, используемых для 
// передачи информации во вспомогательную утилиту. Файл должен быть включен
// как в проект защищенного приложения, так и в проект вспомогательной
// утилиты.
//
// Автор - Сергей Усков (Sergey.Uskov@safenet-inc.com, uskov@smtp.ru)
//*****************************************************************************

#define MaxEccLength  256		// Максимальная длина кода коррекции ошибок (в байтах), используемая в приложении.

#define DB		__asm _emit

#define int3	__asm int 3		\
				__asm nop

//////////////////////////////////////////////////////////////////////////////////////////////
// Структура-дескриптор сессии с ключом.
#ifdef __HASP_API_H__

typedef struct _HaspSession {
	hasp_handle_t	handle;		// Хендл текущей сессии с ключом.
	hasp_status_t	status;		// Код ошибки последней операции.
	hasp_feature_t	feature;	// Feature ID для текущей сессии.
} HaspSession, *PHaspSession;

#endif	//__HASP_API_H__

//######################################################################################################
//#                 Структуры для обеспечения зашифрования данных на post-build этапе                  #
//######################################################################################################

// Маркер, содержащий информацию о данных, которые требуется зашифровать на custom-алгоритме. Обрабатывается 
// утилитой DataEncrypt, после чего перезаписывается случайными данными, т.к. далее нигде не используется.

#define CstEncDataSig	"-C-E-D-"		// Поисковая сигнатура, записываемая в начало маркера.

typedef struct _CstEncDataMrk {
	CHAR  Signature[8];		// Место для поисковой сигнатуры. Используется для обнаружения маркера утилитой.
	PVOID Addr;				// Адрес данных.
	DWORD Length;			// Длина данных.
} CstEncDataMrk, *PCstEncDataMrk;	

// Маркер, содержащий информацию о данных, которые требуется зашифровать на алгоритме AES через ключ. Обрабатывается 
// утилитой DataEncrypt, после чего перезаписывается случайными данными, т.к. далее нигде не используется.
#ifdef __HASP_API_H__

#define KeyEncDataSig	"-K-E-D-"		// Поисковая сигнатура, записываемая в начало маркера.

typedef struct _KeyEncDataMrk {
	CHAR  Signature[8];	// Место для поисковой сигнатуры. Используется для обнаружения маркера утилитой.
	PVOID Addr;			// Адрес данных.
	DWORD Length;		// Длина данных.
	DWORD Feature;		// Feature ID, на которой зашифровываются данные.
} KeyEncDataMrk, *PKeyEncDataMrk;

#endif	//__HASP_API_H__

//######################################################################################################
//#    Структуры для обеспечения контроля целостности данных и кода при помощи хэш-функций (CRC32)     #
//######################################################################################################

// Структура-дескриптор, содержит данные о размещении, длине и эталонной контрольной сумме участка
// данных/кода. Используется во время работы защищенного приложения для контроля целостности участка.
// Заполняется утилитой CRC32Protect на основе информации, полученной из маркеров данных/кода.

typedef struct _CrcDsc {		
	PBYTE	NextDsc;		// Адрес следующего дескриптора, для последнго - NULL
	PBYTE   Addr;			// Адрес данных.
	DWORD   Length;			// Длина данных.
	DWORD   OrgCrc;			// Эталонная контрольная сумма.
	DWORD   CurrCrc;		// Текущая контрольная сумма (используется для вывода диагностики).
	DWORD	Id;				// Идентификатор, используется для вывода диагностики при отладке защиты.
	BOOL	ValidateFlag;	// Соответствует ли дескриптор текущему ImageBase (для приложений с Fixup's)
} CrcDsc, *PCrcDsc;

//------------------------------- ТОЧКА ВХОДА В СПИСОК ДЕСКРИПТОРОВ ------------------------------------

// Структура-контейнер, содержит точку входа в односвязный список дескрипторов _CrcDsc. В случае обнаружения
// данной структуры, утилита CRC32Protect формирует из найденных дескрипторов _CrcDsc список, связывая их через
// поле NextDsc, после чего помещает точку входа списка в поле EntryPoint структуры _CrcDscList. Поле Signature
// заполняется случайными данными для маскировки структуры.

#define CrcDscListSig	"-C-R-E-"		// Поисковая сигнатура, записываемая в начало маркера.

typedef struct _CrcDscList {
	CHAR	Signature[8];	// Место для поисковой сигнатуры. Используется для обнаружения контейнера утилитой.
	PCrcDsc	EntryPoint;		// Точка входа в список дескрипторов _CrcDsc
} CrcDscList, *PCrcDscList;

//------------------------------------- МАРКЕР ЗАЩИТЫ ДАННЫХ -------------------------------------------

// Маркер, содержащий информацию о данных, для которых требуется расчитать контрольную сумму. Обрабатывается 
// утилитой CRC32Protect, после чего перезаписывается случайными данными, т.к. далее нигде не используется.

#define CrcDataSig	"-C-R-D-"			// Поисковая сигнатура, записываемая в начало маркера.

typedef struct _CrcDataMrk {
	CHAR	Signature[8];	// Место для поисковой сигнатуры. Используется для обнаружения маркера утилитой.
	PCrcDsc CrcDscAddr;		// Адрес структуры-дескриптора, соответствующей данному маркеру.
	PVOID	Addr;			// Адрес данных.
	DWORD	Length;			// Длина данных.
	DWORD	Id;				// Идентификатор маркера, используется для вывода диагностики при защите приложения.
} CrcDataMrk, *PCrcDataMrk;

//----------------------------------- МАРКЕР ЗАЩИТЫ СВОЕГО КОДА  ---------------------------------------

// Маркер, содержащий информацию об участке кода, для которого требуется расчитать контрольную сумму. 
// Представлен в двух форматах, а именно - как ассемблерная вставка, т.к. внедрение маркера в приложение
// производится в область исполняемого кода, поскольку требуется работать с метками, и, как обычная структура
// данных, полностью соответствующая ассемблерной вставке, используемая для извлечения информации в утилите
// CRC32Protect. После извлечения перезаписывается случайными данными, т.к. далее нигде не используется.

// Поисковая сигнатура, записываемая в начало маркера, так же, представлена в двух форматах.
#define CrcCodeSig		"-C-R-C-"											// Для _CrcCodeMrk
#define AsmCrcCodeSig	DB '-' DB 'C' DB '-' DB 'R' DB '-' DB 'C' DB '-'	// Для AsmCrcCodeMrk

// Маркер для внедрения в исходный код приложения.
#define AsmCrcCodeMrk(DescriptorAddr, StartAddr, EndAddr, Id)	\
		AsmCrcCodeSig											\
		__asm mov EAX, offset DescriptorAddr					\
		__asm mov EAX, offset StartAddr							\
		__asm mov EAX, offset EndAddr							\
		__asm mov EAX, Id

// Маркер для извлечения информации в утилите CRC32Protect.
#pragma pack(push, 1)		// Выравнивание элементов структуры по границе байта
typedef struct _CrcCodeMrk {
	CHAR  Signature[7];		// Место для поисковой сигнатуры. Используется для обнаружения маркера утилитой.
	BYTE  OpCode0;
	DWORD DescriptorAddr;	// Адрес структуры-дескриптора, соответствующей данному маркеру.
	BYTE  OpCode1;
	DWORD StartAddr;		// Адрес начала участка кода.
	BYTE  OpCode2;
	DWORD EndAddr;			// Адрес конца участка кода.
	BYTE  OpCode3;
	DWORD Id;				// Идентификатор маркера, используется для вывода диагностики при защите приложения.
} CrcCodeMrk, *PCrcCodeMrk;
#pragma pack(pop)

//--------------------------- МАРКЕР ЗАЩИТЫ БИБЛИОТЕЧНОГО (ЧУЖОГО) КОДА  -------------------------------

// Маркер, содержащий информацию об участке библиотечного кода, для которого требуется расчитать контрольную
// сумму. Представлен в двух форматах, а именно - как ассемблерная вставка, т.к. внедрение маркера в приложение
// производится в область исполняемого кода, поскольку требуется работать с произвольными адресами, и, как 
// обычная структура данных, полностью соответствующая ассемблерной вставке, используемая для извлечения информации
// в утилите CRC32Protect. После извлечения перезаписывается случайными данными, т.к. далее нигде не используется.

// Поисковая сигнатура, записываемая в начало маркера, так же, представлена в двух форматах.
#define CrcLibsSig		"-C-R-L-"											// Для _CrcLibsMrk
#define AsmCrcLibsSig	DB '-' DB 'C' DB '-' DB 'R' DB '-' DB 'L' DB '-'	// Для AsmCrcLibsMrk

// Маркер для внедрения в исходный код приложения.
#define AsmCrcLibsMrk(DescriptorAddr, EntryPointAddr, CodeLength, Id)	\
		AsmCrcLibsSig													\
		__asm mov EAX, offset DescriptorAddr							\
		__asm mov EAX, offset EntryPointAddr							\
		__asm mov EAX, CodeLength										\
		__asm mov EAX, Id

// Маркер для извлечения информации в утилите CRC32Protect.
#pragma pack(push, 1)		// Выравнивание элементов структуры по границе байта
typedef struct _CrcLibsMrk {
	CHAR  Signature[7];		// Место для поисковой сигнатуры. Используется для обнаружения маркера утилитой.
	BYTE  OpCode0;
	DWORD DescriptorAddr;	// Адрес структуры-дескриптора, соответствующей данному маркеру.
	BYTE  OpCode1;
	DWORD EntryPointAddr;	// Точка входа защищаемого участка библиотечного кода.
	BYTE  OpCode2;
	DWORD CodeLength;		// Длина защищаемого участка библиотечного кода.
	BYTE  OpCode3;
	DWORD Id;				// Идентификатор маркера, используется для вывода диагностики при защите приложения.
} CrcLibsMrk, *PCrcLibsMrk;
#pragma pack(pop)


//######################################################################################################
//#     Структуры для обеспечения помехозащищенного кодирования данных и кода (коды Рида-Соломона)     #
//######################################################################################################
#ifdef __RSLIB_H__

// Если не задана максимальная длина кода коррекции ошибок, которая может быть использована в приложении,
// берётся значение ECC_MAX из RSLib.h

#ifndef MaxEccLength
	#define MaxEccLength ECC_MAX
#endif

// Структура-дескриптор, содержит данные о размещении, длине и коде коррекции ошибок (ECC) участка данных/кода.
// Используется во время работы защищенного приложения для восстановления целостности участка в случае внесения
// в него изменений. Заполняется утилитой ECCProtect на основе информации, полученной из маркеров данных/кода.

typedef struct _EccDsc {		
	PBYTE	NextDsc;			// Адрес следующего дескриптора, для последнго - NULL
	PBYTE   Addr;				// Адрес данных.
	DWORD   Length;				// Длина данных.
	DWORD	EccLength;			// Длина кода коррекции ошибок.
	DWORD	Id;					// Идентификатор, используется для вывода диагностики при отладке защиты.
	BOOL	ValidateFlag;		// Соответствует ли дескриптор текущему ImageBase (для приложений с Fixup's)
	BYTE    Ecc[MaxEccLength];	// Код коррекции ошибок.
} EccDsc, *PEccDsc;

//------------------------------- ТОЧКА ВХОДА В СПИСОК ДЕСКРИПТОРОВ ------------------------------------

// Структура-контейнер, содержит точку входа в односвязный список дескрипторов _EccDsc. В случае обнаружения
// данной структуры, утилита ECCProtect формирует из найденных дескрипторов _EccDsc список, связывая их через
// поле NextDsc, после чего помещает точку входа списка в поле EntryPoint структуры _EccDscList. Поле Signature
// заполняется случайными данными для маскировки структуры.

#define EccDscListSig	"-E-C-E-"		// Поисковая сигнатура, записываемая в начало маркера.

typedef struct _EccDscList {
	CHAR	Signature[8];	// Место для поисковой сигнатуры. Используется для обнаружения контейнера утилитой.
	PEccDsc	EntryPoint;		// Точка входа в список дескрипторов _EccDsc
} EccDscList, *PEccDscList;

//------------------------------------- МАРКЕР ЗАЩИТЫ ДАННЫХ -------------------------------------------

// Маркер, содержащий информацию о данных, для которых требуется расчитать код коррекции ошибок. Обрабатывается 
// утилитой ECCProtect, после чего перезаписывается случайными данными, т.к. далее нигде не используется.

#define EccDataSig	"-E-C-D-"			// Поисковая сигнатура, записываемая в начало маркера.

typedef struct _EccDataMrk {
	CHAR	 Signature[8];	// Место для поисковой сигнатуры. Используется для обнаружения маркера утилитой.
	PEccDsc  EccDscAddr;	// Адрес структуры-дескриптора, соответствующей данному маркеру.
	PVOID	 Addr;			// Адрес данных.
	DWORD	 Length;		// Длина данных.
	DWORD	 EccLength;		// Длина кода коррекции ошибок.
	DWORD	 Id;			// Идентификатор маркера, используется для вывода диагностики при защите приложения.
} EccDataMrk, *PEccDataMrk;


//----------------------------------- МАРКЕР ЗАЩИТЫ СВОЕГО КОДА  ---------------------------------------

// Маркер, содержащий информацию об участке кода, для которого требуется расчитать код коррекции ошибок. 
// Представлен в двух форматах, а именно - как ассемблерная вставка, т.к. внедрение маркера в приложение
// производится в область исполняемого кода, поскольку требуется работать с метками, и, как обычная структура
// данных, полностью соответствующая ассемблерной вставке, используемая для извлечения информации в утилите
// ECCProtect. После извлечения информации перезаписывается случайными данными, т.к. далее нигде не используется.

// Поисковая сигнатура, записываемая в начало маркера, так же, представлена в двух форматах.
#define EccCodeSig		"-E-C-C-"											// Для _EccCodeMrk
#define AsmEccCodeSig	DB '-' DB 'E' DB '-' DB 'C' DB '-' DB 'C' DB '-'	// Для AsmEccCodeMrk

// Маркер для внедрения в исходный код приложения.
#define AsmEccCodeMrk(DescriptorAddr, StartAddr, EndAddr, EccLength, Id)	\
		AsmEccCodeSig														\
		__asm mov EAX, offset DescriptorAddr								\
		__asm mov EAX, offset StartAddr										\
		__asm mov EAX, offset EndAddr										\
		__asm mov EAX, EccLength											\
		__asm mov EAX, Id

// Маркер для извлечения информации в утилите ECCProtect.
#pragma pack(push, 1)		// Выравнивание элементов структуры по границе байта
typedef struct _EccCodeMrk {
	CHAR  Signature[7];		// Место для поисковой сигнатуры. Используется для обнаружения маркера утилитой.
	BYTE  OpCode0;
	DWORD DescriptorAddr;	// Адрес структуры-дескриптора, соответствующей данному маркеру.
	BYTE  OpCode1;
	DWORD StartAddr;		// Адрес начала участка кода.
	BYTE  OpCode2;
	DWORD EndAddr;			// Адрес конца участка кода.
	BYTE  OpCode3;
	DWORD EccLength;		// Длина кода коррекции ошибок.
	BYTE  OpCode4;
	DWORD Id;				// Идентификатор маркера, используется для вывода диагностики при защите приложения.
} EccCodeMrk, *PEccCodeMrk;
#pragma pack(pop)

//--------------------------- МАРКЕР ЗАЩИТЫ БИБЛИОТЕЧНОГО (ЧУЖОГО) КОДА  -------------------------------

// Маркер, содержащий информацию об участке библиотечного кода, для которого требуется расчитать код коррекции
// ошибок. Представлен в двух форматах, а именно - как ассемблерная вставка, т.к. внедрение маркера в приложение
// производится в область исполняемого кода, поскольку требуется работать с произвольными адресами, и, как 
// обычная структура данных, полностью соответствующая ассемблерной вставке, используемая для извлечения информации
// в утилите ECCProtect. После извлечения перезаписывается случайными данными, т.к. далее нигде не используется.

// Поисковая сигнатура, записываемая в начало маркера, так же, представлена в двух форматах.
#define EccLibsSig		"-E-C-L-"											// Для _EccLibsMrk
#define AsmEccLibsSig	DB '-' DB 'E' DB '-' DB 'C' DB '-' DB 'L' DB '-'	// Для AsmEccLibsMrk

// Маркер для внедрения в исходный код приложения.
#define AsmEccLibsMrk(DescriptorAddr, EntryPointAddr, CodeLength, EccLength, Id)	\
		AsmEccLibsSig																\
		__asm mov EAX, offset DescriptorAddr										\
		__asm mov EAX, offset EntryPointAddr										\
		__asm mov EAX, CodeLength													\
		__asm mov EAX, EccLength													\
		__asm mov EAX, Id	

// Маркер для извлечения информации в утилите ECCProtect.
#pragma pack(push, 1)		// Выравнивание элементов структуры по границе байта
typedef struct _EccLibsMrk {
	char  Signature[7];		// Место для поисковой сигнатуры. Используется для обнаружения маркера утилитой.
	BYTE  OpCode0;
	DWORD DescriptorAddr;	// Адрес структуры-дескриптора, соответствующей данному маркеру.
	BYTE  OpCode1;
	DWORD EntryPointAddr;	// Точка входа защищаемого участка библиотечного кода.
	BYTE  OpCode2;
	DWORD CodeLength;		// Длина защищаемого участка библиотечного кода.
	BYTE  OpCode3;
	DWORD EccLength;		// Длина кода коррекции ошибок.
	BYTE  OpCode4;
	DWORD Id;				// Идентификатор маркера, используется для вывода диагностики при защите приложения.
} EccLibsMrk, *PEccLibsMrk;
#pragma pack(pop)

#endif	// __RSLIB_H__

//######################################################################################################
//# Структуры для обеспечения динамического зашифрования/расшифрования кода во время работы приложения #
//######################################################################################################

//------------------------ ДИНАМИЧЕСКОЕ ШИФРОВАНИЕ КОДА НА CUSTOM-АЛГОРИТМЕ ----------------------------

// Структура-дескриптор, содержит данные о размещении и длине зашифрованного на custom-алгоритме участка кода.
// Используется во время работы защищенного приложения для динамического расшифрования/зашифрования этого участка.
// Зашифрование участка кода и заполнение дескриптора данными осуществляются утилитой CodeEncrypt на основе 
// информации, полученной из маркера AsmCstEncCodeMrk.

typedef struct _CstEncCodeDsc {
	PBYTE	Addr;			// Адрес начала участка кода.
	DWORD	Length;			// Длина участка кода.
	BOOL	ValidateFlag;	// Соответствует ли дескриптор текущему ImageBase (для приложений с Fixup's) 
} CstEncCodeDsc, *PCstEncCodeDsc;

// Маркер, содержащий информацию об участке кода, который требуется зашифровать на custom-алгоритме. 
// Представлен в двух форматах, а именно - как ассемблерная вставка, т.к. внедрение маркера в приложение
// производится в область исполняемого кода, поскольку требуется работать с метками, и, как обычная структура
// данных, полностью соответствующая ассемблерной вставке, используемая для извлечения информации в утилите
// CodeEncrypt. После извлечения информации перезаписывается случайными данными, т.к. далее нигде не используется.

// Поисковая сигнатура, записываемая в начало маркера, так же, представлена в двух форматах.
#define CstEncCodeSig		"-C-E-C-"											// Для _CstEncCodeMrk
#define AsmCstEncCodeSig	DB '-' DB 'C' DB '-' DB 'E' DB '-' DB 'C' DB '-'	// Для AsmCstEncCodeMrk

// Маркер для внедрения в исходный код приложения.
#define AsmCstEncCodeMrk(DescriptorAddr, StartAddr, EndAddr)	\
		AsmCstEncCodeSig										\
		__asm mov EAX, offset DescriptorAddr					\
		__asm mov EAX, offset StartAddr							\
		__asm mov EAX, offset EndAddr	

// Маркер для извлечения информации в утилите CodeEncrypt.
#pragma pack(push, 1)		// Выравнивание элементов структуры по границе байта
typedef struct _CstEncCodeMrk {
	CHAR  Signature[7];		// Место для поисковой сигнатуры. Используется для обнаружения маркера утилитой.
	BYTE  OpCode0;
	DWORD DescriptorAddr;	// Адрес структуры-дескриптора, соответствующей данному маркеру.
	BYTE  OpCode1;
	DWORD StartAddr;		// Адрес начала участка кода.
	BYTE  OpCode2;
	DWORD EndAddr;			// Адрес конца участка кода.
} CstEncCodeMrk, *PCstEncCodeMrk;
#pragma pack(pop)

//-------------------- ДИНАМИЧЕСКОЕ ШИФРОВАНИЕ КОДА НА АЛГОРИТМЕ AES ЧЕРЕЗ КЛЮЧ ------------------------
#ifdef __HASP_API_H__

// Структура-дескриптор, содержит данные о размещении и длине зашифрованного на алгоритме AES (через ключ) участка
// кода. Используется во время работы защищенного приложения для динамического расшифрования/зашифрования этого
// участка. Зашифрование участка кода и заполнение дескриптора данными осуществляются утилитой CodeEncrypt на основе 
// информации, полученной из маркера AsmKeyEncCodeMrk.

typedef struct _KeyEncCodeDsc {
	PHaspSession	KeySessionAddr;		// Адрес дескриптора сессии с ключом, обеспечивающей криптооперации с кодом.
	PBYTE			Addr;				// Адрес начала участка кода.
	DWORD			Length;				// Длина участка кода.
	BOOL			ValidateFlag;		// Соответствует ли дескриптор текущему ImageBase (для приложений с Fixup's) 
} KeyEncCodeDsc, *PKeyEncCodeDsc;

// Маркер, содержащий информацию об участке кода, который требуется зашифровать на алгоритме AES через ключ.
// Представлен в двух форматах, а именно - как ассемблерная вставка, т.к. внедрение маркера в приложение
// производится в область исполняемого кода, поскольку требуется работать с метками, и, как обычная структура
// данных, полностью соответствующая ассемблерной вставке, используемая для извлечения информации в утилите
// CodeEncrypt. После извлечения информации перезаписывается случайными данными, т.к. далее нигде не используется.

// Поисковая сигнатура, записываемая в начало маркера, так же, представлена в двух форматах.
#define KeyEncCodeSig		"-K-E-C-"											// Для _KeyEncCodeMrk
#define AsmKeyEncCodeSig	DB '-' DB 'K' DB '-' DB 'E' DB '-' DB 'C' DB '-'	// Для AsmKeyEncCodeMrk

// Маркер для внедрения в исходный код приложения.
#define AsmKeyEncCodeMrk(DescriptorAddr, StartAddr, EndAddr, KeySessionAddr)	\
		AsmKeyEncCodeSig														\
		__asm mov EAX, offset DescriptorAddr									\
		__asm mov EAX, offset StartAddr											\
		__asm mov EAX, offset EndAddr											\
		__asm mov EAX, offset KeySessionAddr

// Маркер для извлечения информации в утилите CodeEncrypt.
#pragma pack(push, 1)		// Выравнивание элементов структуры по границе байта
typedef struct _KeyEncCodeMrk {
	CHAR  Signature[7];		// Место для поисковой сигнатуры. Используется для обнаружения маркера утилитой.
	BYTE  OpCode0;
	DWORD DescriptorAddr;	// Адрес структуры-дескриптора, соответствующей данному маркеру.
	BYTE  OpCode1;
	DWORD StartAddr;		// Адрес начала участка кода.
	BYTE  OpCode2;
	DWORD EndAddr;			// Адрес конца участка кода.
	BYTE  OpCode3;
	DWORD KeySessionAddr;	// Адрес дескриптора сессии с ключом, обеспечивающей криптооперации с кодом.
} KeyEncCodeMrk, *PKeyEncCodeMrk;
#pragma pack(pop)

#endif	//__HASP_API_H__

//----- ПОДДЕРЖКА ДИНАМИЧЕСКОГО ШИФРОВАНИЯ КОДА ЧЕРЕЗ МЕХАНИЗМЫ ОБРАБОТКИ ИСКЛЮЧИТЕЛЬНЫХ СИТУАЦИЙ ------

// Отключение предупреждений компилятора о том, что устанавливаемые обработчики исключительных ситуаций не
// являются надежными. Источником предупреждений является механизм SafeSEH (защита от подмены SEH-обработчика
// при атаке на переполняющиеся буфера). 

#pragma warning(disable : 4733)

// Установка внутрипоточного SEH-обработчика исключительной ситуации. Создаем на стеке SEH-Record (узел) 
// обработчика и регистрируем его как текущий:
// push	offset ExceptionHandler	-> помещаем в стек адрес устанавливаемого обработчика исключительной ситуации.
// push FS:[0]					-> помещаем в стек адрес SEH-Record предыдущего обработчика.
// mov  FS:[0], ESP				-> регистрируем только что созданную SEH-Record, как узел текущего обработчика.

#define InstallHandler(ExceptionHandler)		\
		__asm push offset ExceptionHandler		\
		__asm push FS:[0]						\
		__asm mov  FS:[0], ESP

// Снятие текущего внутрипоточного SEH-обработчика исключительной ситуации. Регистрируем в качестве текущего
// предыдущий обработчик, помещая адрес его узла обратно в FS:[0] из первого поля SEH-Record, после чего
// удаляем из стека второе поле SEH-Record, более нам не нужное: 
// pop  dword ptr FS:[0]	-> регистрируем узел предыдущего обработчика (SEH-Record), как текущий.
// add  ESP, 4				-> удаляем из стека остатки SEH-Record. Ну, можно, нпример, и так - pop EAX.

#define RemoveHandler							\
		__asm pop  dword ptr FS:[0]				\
		__asm add  ESP, 4


// РАСШИФРОВАНИЕ УЧАСТКА КОДА НА CUSTOM-АЛГОРИТМЕ. Макроопределение RaiseExceptionForCustomDecrypt формирует
// "пятно", вызывающее исключение при проходе управления по нему. "Пятно", так же, содержит дескриптор участка
// кода и адрес точки входа, куда нужно передать управление после завершения обработки исключительной ситуации.
// Доступ к параметрам, лежащим в "пятне", из обработчика исключения осуществляется через структуру _RaiseExcept.

#define CstDecInvalidOpCode		0x3A0F				// Для использования с _RaiseExcept.InvalidOpCode
#define AsmCstDecInvalidOpCode	DB 0x0F	DB 0x3A		// Для RaiseExceptionForCustomDecrypt (Little Endian)

#define RaiseExceptionForCustomDecrypt(Descriptor, SafeEIP)		\
		AsmCstDecInvalidOpCode									\
		__asm mov  ESP, offset Descriptor						\
		__asm mov  ESP, SafeEIP

// ЗАШИФРОВАНИЕ УЧАСТКА КОДА НА CUSTOM-АЛГОРИТМЕ. Макроопределение RaiseExceptionForCustomEncrypt формирует
// "пятно", вызывающее исключение при проходе управления по нему. "Пятно", так же, содержит дескриптор участка
// кода и адрес точки входа, куда нужно передать управление после завершения обработки исключительной ситуации.
// Доступ к параметрам, лежащим в "пятне", из обработчика исключения осуществляется через структуру _RaiseExcept.

#define CstEncInvalidOpCode		0x3B0F				// Для использования с _RaiseExcept.InvalidOpCode
#define AsmCstEncInvalidOpCode	DB 0x0F	DB 0x3B		// Для RaiseExceptionForCustomEncrypt (Little Endian)

#define RaiseExceptionForCustomEncrypt(Descriptor, SafeEIP)		\
		AsmCstEncInvalidOpCode									\
		__asm mov  ESP, offset Descriptor						\
		__asm mov  ESP, SafeEIP

// РАСШИФРОВАНИЕ УЧАСТКА КОДА НА АЛГОРИТМЕ AES ЧЕРЕЗ КЛЮЧ. Макроопределение RaiseExceptionForKeyDecrypt формирует
// "пятно", вызывающее исключение при проходе управления по нему. "Пятно", так же, содержит дескриптор участка
// кода и адрес точки входа, куда нужно передать управление после завершения обработки исключительной ситуации.
// Доступ к параметрам, лежащим в "пятне", из обработчика исключения осуществляется через структуру _RaiseExcept.

#define KeyDecInvalidOpCode		0x3C0F				// Для использования с _RaiseExcept.InvalidOpCode
#define AsmKeyDecInvalidOpCode	DB 0x0F	DB 0x3C		// Для RaiseExceptionForKeyDecrypt (Little Endian)

#define RaiseExceptionForKeyDecrypt(Descriptor, SafeEIP)		\
		AsmKeyDecInvalidOpCode									\
		__asm mov  ESP, offset Descriptor						\
		__asm mov  ESP, SafeEIP

// ЗАШИФРОВАНИЕ УЧАСТКА КОДА НА АЛГОРИТМЕ AES ЧЕРЕЗ КЛЮЧ. Макроопределение RaiseExceptionForKeyEncrypt формирует
// "пятно", вызывающее исключение при проходе управления по нему. "Пятно", так же, содержит дескриптор участка
// кода и адрес точки входа, куда нужно передать управление после завершения обработки исключительной ситуации.
// Доступ к параметрам, лежащим в "пятне", из обработчика исключения осуществляется через структуру _RaiseExcept.

#define KeyEncInvalidOpCode		0x3D0F				// Для использования с _RaiseExcept.InvalidOpCode
#define AsmKeyEncInvalidOpCode	DB 0x0F	DB 0x3D		// Для RaiseExceptionForKeyEncrypt (Little Endian)	

#define RaiseExceptionForKeyEncrypt(Descriptor, SafeEIP)		\
		AsmKeyEncInvalidOpCode									\
		__asm mov  ESP, offset Descriptor						\
		__asm mov  ESP, SafeEIP

// Mакроопределения RaiseExceptionFor**, формирующие "пятно", создают характерную стационарную сигнатуру вида
// "0F xx BC xx xx xx xx BC xx xx xx xx". Утилита CodeEncrypt разыскивает такие сигнатуры и меняет опкоды
// инструкций, в операндах которых лежат параметры "пятна", на случайные данные, таким образом маскируя сигнатуры.

#define FirstByteBadOpCode  0x0F	// Первый байт всех "плохих" инструкций
#define ExceptionDataOpCode 0xBC	// Опкод инструкции mov ESP,... используемой как контейнер параметра. 

// Структура _RaiseExcept полностью соответствует макроопределениям RaiseExceptionFor**, формирующим "пятно",
// вызывающее исключение, и служит для получения параметров "пятна" изнутри обработчика исключительной ситуации.

#pragma pack(push, 1)			// Выравнивание элементов структуры по границе байта
typedef struct _RaiseExcept {
	WORD  InvalidOpCode;		// "Плохая" инструкция, вызывающая исключение.
	BYTE  OpCode0;
	DWORD DescriptorAddr;		// Адрес дескриптора, описывающего зашифрованный участок кода.
	BYTE  OpCode1;
	DWORD SafeEIPAddr;			// Адрес безопасной точки входа, куда передается управление после обработки исключения.
} RaiseExcept, *PRaiseExcept;	// Если SafeEIPAddr == NULL - то на следующую, после структуры RaiseExcept, инструкцию.
#pragma pack(pop)


//######################################################################################################
//#                    Структуры для обеспечения использования функций TLS_Callback                    #
//######################################################################################################

#define TLSDirSign	"-T-L-S-"			// Поисковая сигнатура, записываемая в начало маркера.

// Структура, содержащая поисковую сигнатуру и адрес TLS_Directory. Используется для передачи 
// адреса TLS_Directory в утилиту ECCProtect, подключаемую на post-build этапе. ECCProtect,
// запущенная с параметром /tls, зарегистрирует TLS_Directory в PE-заголовке целевого файла.

typedef struct _TLS {	
	CHAR	Signature[8];	// Место для поисковой сигнатуры. Используется для обнаружения маркера утилитой.
	PVOID	TlsDirAddr;		// Адрес TLS_Directory
} TLS, *PTLS;


//######################################################################################################
//#                 Структуры для обеспечения противодействия табличной эмуляции ключа                 #
//######################################################################################################

// Часть инструкций закодирована непосредственно в машинных кодах - это сделано с целью избежать
// использования внутри макросов символьных меток, что позволяет предотвратить конфликт между метками
// по именам в случае многократного использования макроса в пределах кода одной и той же процедуры. 

// Размещение четырехбайтовой переменной (DWORD) внутри исполняемого кода. Первые два байта 
// (EBh 04h) - инструкция короткого перехода для обхода переменной, var - метка для взятия
// адреса, где будет размещена переменная.

#define DWORDVarInCode(var)								\
			__asm		DB 0xEB DB 0x04					\
			__asm  var: DB 0 DB 0 DB 0 DB 0

// Самодостаточный базонезависимый фрагмент, не связанный с логикой работы окружающего его кода.
// При каждом проходе управления сохраняет внутри себя текущее значение системного таймера (двойное
// слово в предпоследней инструкции). Это приводит к тому, что при каждом проходе управления меняется
// сигнатура фрагмента, таким образом, создавая изменяющийся случайным образом "шум" в текущей локации. 

// DB 0xE8 DB 0 DB 0 DB 0 DB 0 - инструкция call $+5 (помещает в стек адрес следующей инструкции, длина call - 5 байт)
// DB 0xEB DB 0x04             - инструкция jmp  $+2+4 ($ - адрес текущей инструкции, длина jmp short - 2 байта)
// DB 0 DB 0 DB 0 DB 0         - место для хранения текущего значения системного таймера.

#define NoiseInCode()	GetTickCount();					\
			__asm		push EBX						\
			__asm		DB 0xE8 DB 0 DB 0 DB 0 DB 0		\
			__asm		pop  EBX						\
			__asm		add  EBX, 8						\
			__asm		mov  dword ptr [EBX], EAX		\
			__asm		DB 0xEB DB 0x04					\
			__asm		DB 0 DB 0 DB 0 DB 0				\
			__asm		pop  EBX


//######################################################################################################
//#   Структуры для обеспечения использования чувствительных к fixup'ам алгоритмов совместно с ними    #
//######################################################################################################

// Структура-контейнер для хранения оригинального значения ImageBase. Если приложение собрано с использованием
// технологии ASLR (Address Space Layout Randomization), то в процессе загрузки базовый адрес приложения будет
// произвольно изменен системным загрузчиком путем перезаписи исходного значения в PE-заголовке образа. После
// этого узнать исходное значение ImageBase, с использованием которого считались хэш-суммы, коды коррекции 
// ошибок и зашифровывался код, будет невозможно. Поэтому ImageBase заранее сохраняется в данный контейнер одной
// из следующих утилит: CRC32Protect, ECCProtect или CodeEncrypt. В случае, если контейнер обнаружен одной из них,
// он заполняется с выдачей соответствующей информации в окно вывода. В случае, если контейнер не обнаружен,
// никаких предупреждений не выдается, поэтому за необходимостью наличия контейнера нужно следить самостоятельно. 

#define OrgPESig	"-O-I-B-"		// Поисковая сигнатура, записываемая в начало маркера.

typedef struct _OrgPE {
	CHAR	Signature[8];	// Место для поисковой сигнатуры. Используется для обнаружения контейнера утилитой.
	DWORD	ImageBase;		// Исходное значение ImageBase
} OrgPE, *POrgPE;

//BYTE	AddrStub;			// Заглушка, используется для инициализации адресных полей целевых дескрипторов,
							// чтобы при сборке эти поля были помечены компоновщиком, как перемещаемые элементы.


#endif // __MACROS_H__